Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/**
 * Base Animation class
 */
class Animation {
    _debounceOnEnd(result) {
        const onEnd = this._onEnd;
        const onRest = this._onRest;
        this._onEnd = null;
        this._onRest = null;
        onRest && onRest(result);
        onEnd && onEnd(result);
    }
    stop() { }
}

const RequestAnimationFrame = {
    current: (cb) => global.requestAnimationFrame(cb),
    inject(injected) {
        RequestAnimationFrame.current = injected;
    },
};
const CancelAnimationFrame = {
    current: (id) => global.cancelAnimationFrame(id),
    inject(injected) {
        CancelAnimationFrame.current = injected;
    },
};

/**
 * Class implementing spring based animation
 */
class SpringAnimation extends Animation {
    constructor({ initialPosition, config, }) {
        var _a, _b, _c, _d, _e, _f;
        super();
        this._overshootClamping = false;
        this._initialVelocity = 0;
        this._lastVelocity = 0;
        this._startPosition = initialPosition;
        this._position = this._startPosition;
        this._restDisplacementThreshold = (_a = config === null || config === void 0 ? void 0 : config.restDistance) !== null && _a !== void 0 ? _a : 0.001;
        this._restSpeedThreshold = (_b = config === null || config === void 0 ? void 0 : config.restDistance) !== null && _b !== void 0 ? _b : 0.001;
        this._mass = (_c = config === null || config === void 0 ? void 0 : config.mass) !== null && _c !== void 0 ? _c : 1;
        this._tension = (_d = config === null || config === void 0 ? void 0 : config.tension) !== null && _d !== void 0 ? _d : 170;
        this._friction = (_e = config === null || config === void 0 ? void 0 : config.friction) !== null && _e !== void 0 ? _e : 26;
        this._delay = (_f = config === null || config === void 0 ? void 0 : config.delay) !== null && _f !== void 0 ? _f : 0;
        this._onRest = config === null || config === void 0 ? void 0 : config.onRest;
        this._onChange = config === null || config === void 0 ? void 0 : config.onChange;
    }
    onChange(value) {
        this._onFrame(value);
        if (this._lastPosition !== value) {
            if (this._onChange) {
                this._onChange(value);
            }
        }
        this._lastPosition = value;
    }
    onUpdate() {
        var now = Date.now();
        const deltaTime = Math.min(now - this._lastTime, 64);
        this._lastTime = now;
        const c = this._friction;
        const m = this._mass;
        const k = this._tension;
        const v0 = -this._lastVelocity;
        const x0 = this._toValue - this._position;
        const zeta = c / (2 * Math.sqrt(k * m)); // damping ratio
        const omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)
        const omega1 = omega0 * Math.sqrt(1 - Math.pow(zeta, 2)); // exponential decay
        const t = deltaTime / 1000;
        const sin1 = Math.sin(omega1 * t);
        const cos1 = Math.cos(omega1 * t);
        // under damped
        const underDampedEnvelope = Math.exp(-zeta * omega0 * t);
        const underDampedFrag1 = underDampedEnvelope *
            (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);
        const underDampedPosition = this._toValue - underDampedFrag1;
        // This looks crazy -- it's actually just the derivative of the oscillation function
        const underDampedVelocity = zeta * omega0 * underDampedFrag1 -
            underDampedEnvelope *
                (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);
        // critically damped
        const criticallyDampedEnvelope = Math.exp(-omega0 * t);
        const criticallyDampedPosition = this._toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);
        const criticallyDampedVelocity = criticallyDampedEnvelope *
            (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);
        this.onChange(this._position);
        const isOvershooting = () => {
            if (this._overshootClamping && this._tension !== 0) {
                return this._position < this._toValue
                    ? this._position > this._toValue
                    : this._position < this._toValue;
            }
            else {
                return false;
            }
        };
        const isVelocity = Math.abs(this._lastVelocity) < this._restSpeedThreshold;
        const isDisplacement = this._tension === 0 ||
            Math.abs(this._toValue - this._position) <
                this._restDisplacementThreshold;
        if (zeta < 1) {
            this._position = underDampedPosition;
            this._lastVelocity = underDampedVelocity;
        }
        else {
            this._position = criticallyDampedPosition;
            this._lastVelocity = criticallyDampedVelocity;
        }
        if (isOvershooting() || (isVelocity && isDisplacement)) {
            if (this._tension !== 0) {
                this._lastVelocity = 0;
                this._position = this._toValue;
                this.onChange(this._position);
            }
            // clear lastTimestamp to avoid using stale value by the next spring animation that starts after this one
            this._lastTime = 0;
            this._debounceOnEnd({ finished: true, value: this._toValue });
            return;
        }
        this._animationFrame = RequestAnimationFrame.current(this.onUpdate.bind(this));
    }
    stop() {
        this._active = false;
        clearTimeout(this._timeout);
        CancelAnimationFrame.current(this._animationFrame);
        this._debounceOnEnd({ finished: false, value: this._position });
    }
    // Set value
    set(toValue) {
        this.stop();
        this._position = toValue;
        this._lastTime = 0;
        this._lastVelocity = 0;
        this.onChange(toValue);
    }
    start({ toValue, onFrame, previousAnimation, onEnd, }) {
        const onStart = () => {
            this._onFrame = onFrame;
            this._active = true;
            this._toValue = toValue;
            this._onEnd = onEnd;
            const now = Date.now();
            if (previousAnimation instanceof SpringAnimation) {
                this._lastVelocity =
                    previousAnimation._lastVelocity || this._lastVelocity || 0;
                this._lastTime = previousAnimation._lastTime || now;
            }
            else {
                this._lastTime = now;
            }
            this._animationFrame = RequestAnimationFrame.current(this.onUpdate.bind(this));
        };
        if (this._delay !== 0) {
            this._timeout = setTimeout(() => onStart(), this._delay);
        }
        else {
            onStart();
        }
    }
}

/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 */
// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
var float32ArraySupported = typeof Float32Array === "function";
function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
}
function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
}
function C(aA1) {
    return 3.0 * aA1;
}
// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
}
// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}
function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
            aB = currentT;
        }
        else {
            aA = currentT;
        }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION &&
        ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
}
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0.0) {
            return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
}
function LinearEasing(x) {
    return x;
}
function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error("bezier x values must be in [0, 1] range");
    }
    if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
    }
    // Precompute samples table
    var sampleValues = float32ArraySupported
        ? new Float32Array(kSplineTableSize)
        : new Array(kSplineTableSize);
    for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    function getTForX(aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
        }
        --currentSample;
        // Interpolate to provide an initial guess for t
        var dist = (aX - sampleValues[currentSample]) /
            (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        }
        else if (initialSlope === 0.0) {
            return guessForT;
        }
        else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
    }
    return function BezierEasing(x) {
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0 || x === 1) {
            return x;
        }
        return calcBezier(getTForX(x), mY1, mY2);
    };
}

/**
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
 * This class implements common easing functions. The math is pretty obscure,
 * but this cool website has nice visual illustrations of what they represent:
 * http://xaedes.de/dev/transitions/
 */
class Easing {
    static step0(n) {
        return n > 0 ? 1 : 0;
    }
    static step1(n) {
        return n >= 1 ? 1 : 0;
    }
    static linear(t) {
        return t;
    }
    static ease(t) {
        return ease(t);
    }
    static quad(t) {
        return t * t;
    }
    static cubic(t) {
        return t * t * t;
    }
    static poly(n) {
        return (t) => Math.pow(t, n);
    }
    static sin(t) {
        return 1 - Math.cos((t * Math.PI) / 2);
    }
    static circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    static exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    /**
     * A simple elastic interaction, similar to a spring.  Default bounciness
     * is 1, which overshoots a little bit once.  0 bounciness doesn't overshoot
     * at all, and bounciness of N > 1 will overshoot about N times.
     *
     * Wolfram Plots:
     *
     *   http://tiny.cc/elastic_b_1 (default bounciness = 1)
     *   http://tiny.cc/elastic_b_3 (bounciness = 3)
     */
    static elastic(bounciness = 1) {
        var p = bounciness * Math.PI;
        return (t) => 1 - Math.pow(Math.cos((t * Math.PI) / 2), 3) * Math.cos(t * p);
    }
    static back(s) {
        if (s === undefined) {
            s = 1.70158;
        }
        return (t) => t * t * ((s + 1) * t - s);
    }
    static bounce(t) {
        if (t < 1 / 2.75) {
            return 7.5625 * t * t;
        }
        if (t < 2 / 2.75) {
            t -= 1.5 / 2.75;
            return 7.5625 * t * t + 0.75;
        }
        if (t < 2.5 / 2.75) {
            t -= 2.25 / 2.75;
            return 7.5625 * t * t + 0.9375;
        }
        t -= 2.625 / 2.75;
        return 7.5625 * t * t + 0.984375;
    }
    static bezier(x1, y1, x2, y2) {
        return bezier(x1, y1, x2, y2);
    }
    static in(easing) {
        return easing;
    }
    /**
     * Runs an easing function backwards.
     */
    static out(easing) {
        return (t) => 1 - easing(1 - t);
    }
    /**
     * Makes any easing function symmetrical.
     */
    static inOut(easing) {
        return (t) => {
            if (t < 0.5) {
                return easing(t * 2) / 2;
            }
            return 1 - easing((1 - t) * 2) / 2;
        };
    }
}
var ease = Easing.bezier(0.42, 0, 1, 1);

/**
 * Class implementing timing based animation
 */
class TimingAnimation extends Animation {
    constructor({ initialPosition, config, }) {
        var _a, _b, _c;
        super();
        this._fromValue = initialPosition;
        this._position = this._fromValue;
        this._easing = (_a = config === null || config === void 0 ? void 0 : config.easing) !== null && _a !== void 0 ? _a : Easing.linear;
        this._duration = (_b = config === null || config === void 0 ? void 0 : config.duration) !== null && _b !== void 0 ? _b : 500;
        this._tempDuration = this._duration;
        // Modifiers
        // here immediate acts like duration: 0
        if (config === null || config === void 0 ? void 0 : config.immediate) {
            this._duration = 0;
        }
        this._delay = (_c = config === null || config === void 0 ? void 0 : config.delay) !== null && _c !== void 0 ? _c : 0;
        this._onRest = config === null || config === void 0 ? void 0 : config.onRest;
        this._onChange = config === null || config === void 0 ? void 0 : config.onChange;
    }
    onChange(value) {
        this._onFrame(value);
        if (this._lastPosition !== value) {
            if (this._onChange) {
                this._onChange(value);
            }
        }
        this._lastPosition = value;
    }
    onUpdate() {
        const now = Date.now();
        const runTime = now - this._startTime;
        if (runTime >= this._duration) {
            this._startTime = 0;
            this._position = this._toValue;
            this.onChange(this._position);
            this._debounceOnEnd({ finished: true, value: this._position });
            return;
        }
        const progress = this._easing(runTime / this._duration);
        this._position =
            this._fromValue + (this._toValue - this._fromValue) * progress;
        this.onChange(this._position);
        this._animationFrame = RequestAnimationFrame.current(this.onUpdate.bind(this));
    }
    stop() {
        this._active = false;
        clearTimeout(this._timeout);
        CancelAnimationFrame.current(this._animationFrame);
        this._debounceOnEnd({ finished: false, value: this._position });
    }
    // Set value
    set(toValue) {
        this.stop();
        this._position = toValue;
        this.onChange(toValue);
    }
    start({ toValue, onFrame, previousAnimation, onEnd, }) {
        const onStart = () => {
            this._onFrame = onFrame;
            this._active = true;
            this._onEnd = onEnd;
            this._toValue = toValue;
            if (previousAnimation &&
                previousAnimation instanceof TimingAnimation &&
                previousAnimation._toValue === toValue &&
                previousAnimation._startTime) {
                this._startTime = previousAnimation._startTime;
                this._fromValue = previousAnimation._fromValue;
            }
            else {
                const now = Date.now();
                this._startTime = now;
                this._fromValue = this._position;
            }
            this._animationFrame = RequestAnimationFrame.current(this.onUpdate.bind(this));
        };
        if (this._delay !== 0) {
            this._timeout = setTimeout(() => onStart(), this._delay);
        }
        else {
            onStart();
        }
    }
}

const COLOR_NUMBER_REGEX = /[+-]?\d+(\.\d+)?|[\s]?\.\d+|#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/gi;
const HEX_NAME_COLOR = /#[a-f\d]{3,}|transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|burntsienna|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen/gi;
// Named colors
const colorNames = {
    transparent: "#00000000",
    aliceblue: "#f0f8ffff",
    antiquewhite: "#faebd7ff",
    aqua: "#00ffffff",
    aquamarine: "#7fffd4ff",
    azure: "#f0ffffff",
    beige: "#f5f5dcff",
    bisque: "#ffe4c4ff",
    black: "#000000ff",
    blanchedalmond: "#ffebcdff",
    blue: "#0000ffff",
    blueviolet: "#8a2be2ff",
    brown: "#a52a2aff",
    burlywood: "#deb887ff",
    burntsienna: "#ea7e5dff",
    cadetblue: "#5f9ea0ff",
    chartreuse: "#7fff00ff",
    chocolate: "#d2691eff",
    coral: "#ff7f50ff",
    cornflowerblue: "#6495edff",
    cornsilk: "#fff8dcff",
    crimson: "#dc143cff",
    cyan: "#00ffffff",
    darkblue: "#00008bff",
    darkcyan: "#008b8bff",
    darkgoldenrod: "#b8860bff",
    darkgray: "#a9a9a9ff",
    darkgreen: "#006400ff",
    darkgrey: "#a9a9a9ff",
    darkkhaki: "#bdb76bff",
    darkmagenta: "#8b008bff",
    darkolivegreen: "#556b2fff",
    darkorange: "#ff8c00ff",
    darkorchid: "#9932ccff",
    darkred: "#8b0000ff",
    darksalmon: "#e9967aff",
    darkseagreen: "#8fbc8fff",
    darkslateblue: "#483d8bff",
    darkslategray: "#2f4f4fff",
    darkslategrey: "#2f4f4fff",
    darkturquoise: "#00ced1ff",
    darkviolet: "#9400d3ff",
    deeppink: "#ff1493ff",
    deepskyblue: "#00bfffff",
    dimgray: "#696969ff",
    dimgrey: "#696969ff",
    dodgerblue: "#1e90ffff",
    firebrick: "#b22222ff",
    floralwhite: "#fffaf0ff",
    forestgreen: "#228b22ff",
    fuchsia: "#ff00ffff",
    gainsboro: "#dcdcdcff",
    ghostwhite: "#f8f8ffff",
    gold: "#ffd700ff",
    goldenrod: "#daa520ff",
    gray: "#808080ff",
    green: "#008000ff",
    greenyellow: "#adff2fff",
    grey: "#808080ff",
    honeydew: "#f0fff0ff",
    hotpink: "#ff69b4ff",
    indianred: "#cd5c5cff",
    indigo: "#4b0082ff",
    ivory: "#fffff0ff",
    khaki: "#f0e68cff",
    lavender: "#e6e6faff",
    lavenderblush: "#fff0f5ff",
    lawngreen: "#7cfc00ff",
    lemonchiffon: "#fffacdff",
    lightblue: "#add8e6ff",
    lightcoral: "#f08080ff",
    lightcyan: "#e0ffffff",
    lightgoldenrodyellow: "#fafad2ff",
    lightgray: "#d3d3d3ff",
    lightgreen: "#90ee90ff",
    lightgrey: "#d3d3d3ff",
    lightpink: "#ffb6c1ff",
    lightsalmon: "#ffa07aff",
    lightseagreen: "#20b2aaff",
    lightskyblue: "#87cefaff",
    lightslategray: "#778899ff",
    lightslategrey: "#778899ff",
    lightsteelblue: "#b0c4deff",
    lightyellow: "#ffffe0ff",
    lime: "#00ff00ff",
    limegreen: "#32cd32ff",
    linen: "#faf0e6ff",
    magenta: "#ff00ffff",
    maroon: "#800000ff",
    mediumaquamarine: "#66cdaaff",
    mediumblue: "#0000cdff",
    mediumorchid: "#ba55d3ff",
    mediumpurple: "#9370dbff",
    mediumseagreen: "#3cb371ff",
    mediumslateblue: "#7b68eeff",
    mediumspringgreen: "#00fa9aff",
    mediumturquoise: "#48d1ccff",
    mediumvioletred: "#c71585ff",
    midnightblue: "#191970ff",
    mintcream: "#f5fffaff",
    mistyrose: "#ffe4e1ff",
    moccasin: "#ffe4b5ff",
    navajowhite: "#ffdeadff",
    navy: "#000080ff",
    oldlace: "#fdf5e6ff",
    olive: "#808000ff",
    olivedrab: "#6b8e23ff",
    orange: "#ffa500ff",
    orangered: "#ff4500ff",
    orchid: "#da70d6ff",
    palegoldenrod: "#eee8aaff",
    palegreen: "#98fb98ff",
    paleturquoise: "#afeeeeff",
    palevioletred: "#db7093ff",
    papayawhip: "#ffefd5ff",
    peachpuff: "#ffdab9ff",
    peru: "#cd853fff",
    pink: "#ffc0cbff",
    plum: "#dda0ddff",
    powderblue: "#b0e0e6ff",
    purple: "#800080ff",
    rebeccapurple: "#663399ff",
    red: "#ff0000ff",
    rosybrown: "#bc8f8fff",
    royalblue: "#4169e1ff",
    saddlebrown: "#8b4513ff",
    salmon: "#fa8072ff",
    sandybrown: "#f4a460ff",
    seagreen: "#2e8b57ff",
    seashell: "#fff5eeff",
    sienna: "#a0522dff",
    silver: "#c0c0c0ff",
    skyblue: "#87ceebff",
    slateblue: "#6a5acdff",
    slategray: "#708090ff",
    slategrey: "#708090ff",
    snow: "#fffafaff",
    springgreen: "#00ff7fff",
    steelblue: "#4682b4ff",
    tan: "#d2b48cff",
    teal: "#008080ff",
    thistle: "#d8bfd8ff",
    tomato: "#ff6347ff",
    turquoise: "#40e0d0ff",
    violet: "#ee82eeff",
    wheat: "#f5deb3ff",
    white: "#ffffffff",
    whitesmoke: "#f5f5f5ff",
    yellow: "#ffff00ff",
    yellowgreen: "#9acd32ff",
};
function conv3to6(hex) {
    const regex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    return hex.replace(regex, function (_, r, g, b) {
        return "#" + r + r + g + g + b + b;
    });
}
function conv6to8(hex) {
    if (hex.length === 7) {
        return hex + "FF";
    }
    return hex;
}
function hexToRgba(hex) {
    const hex6 = conv3to6(hex);
    const hex8 = conv6to8(hex6);
    const hexRgba = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex8);
    return {
        r: parseInt(hexRgba[1], 16),
        g: parseInt(hexRgba[2], 16),
        b: parseInt(hexRgba[3], 16),
        a: parseInt(hexRgba[4], 16) / 255,
    };
}
function rgbaToHex(rgba) {
    const { r, g, b, a } = rgba;
    const hexR = (r | (1 << 8)).toString(16).slice(1);
    const hexG = (g | (1 << 8)).toString(16).slice(1);
    const hexB = (b | (1 << 8)).toString(16).slice(1);
    const hexA = ((a * 255) | (1 << 8)).toString(16).slice(1);
    return "#" + hexR + hexG + hexB + hexA;
}

/**
 * isTransitionValue to check the value is TransitionValue or not
 * @param value - any
 * @returns - boolean
 */
const isTransitionValue = (value) => {
    return (typeof value === 'object' &&
        Object.prototype.hasOwnProperty.call(value, '_subscribe'));
};

/**
 * Function to get the array of animatable objects
 * @param propertyType - which property type "props" or "style"
 */
function getAnimatableObject(propertyType, propertiesObject) {
    return Object.keys(propertiesObject).reduce(function (acc, styleProp) {
        const value = propertiesObject[styleProp];
        if (isTransitionValue(value)) {
            const { _value } = value;
            return [
                ...acc,
                Object.assign({ propertyType, property: styleProp, animatable: !(typeof _value === 'string') }, value),
            ];
        }
        return acc;
    }, []);
}

/**
 * style keys which can be accepted by animated component
 */
const styleTrasformKeys = [
    'perspective',
    'translate',
    'translateX',
    'translateY',
    'translateZ',
    'scale',
    'scaleX',
    'scaleY',
    'scaleZ',
    'rotate',
    'rotateX',
    'rotateY',
    'rotateZ',
    'skew',
    'skewX',
    'skewY',
];
function splitCSSValueAndUnit(value) {
    const valueMatch = value.match(/(-)?(\d+.)?\d+/g);
    const unitMatch = value.match(/px|rem|em|ex|%|cm|mm|in|pt|pc|ch|vh|vw|vmin|vmax/);
    return {
        value: Number(valueMatch),
        unit: unitMatch && unitMatch[0],
    };
}
// get unit of transform style property
function getValueUnit(property, value) {
    let unit;
    const splitValue = splitCSSValueAndUnit(String(value)).value;
    const splitUnit = splitCSSValueAndUnit(String(value)).unit;
    // if string value is passed with unit then split it
    if (splitUnit) {
        return { value: splitValue, unit: splitUnit };
    }
    if (property.indexOf('translate') !== -1 ||
        property.indexOf('perspective') !== -1) {
        unit = 'px';
    }
    else if (property.indexOf('scale') !== -1) {
        unit = '';
    }
    else if (property.indexOf('rotate') !== -1 ||
        property.indexOf('skew') !== -1) {
        unit = 'deg';
    }
    return { value, unit };
}
function getTransformValueWithUnits(property, value) {
    const valueUnit = getValueUnit(property, value);
    if (property.indexOf('X') !== -1 ||
        property.indexOf('Y') !== -1 ||
        property.indexOf('Z') !== -1 ||
        property.indexOf('perspective') !== -1 ||
        property.indexOf('rotate') !== -1 ||
        property.indexOf('skew') !== -1) {
        // axis value
        return `${property}(${valueUnit.value}${valueUnit.unit})`;
    }
    else if (property.indexOf('translate') !== -1 ||
        property.indexOf('scale') !== -1) {
        // two parameter value
        return `${property}(${valueUnit.value}${valueUnit.unit}, ${valueUnit.value}${valueUnit.unit})`;
    }
    else {
        throw new Error(`Error! Property '${property}' cannot be transformed`);
    }
}
/**
 * getTransform function returns transform string from style object
 */
function getTransform(style) {
    const styleKeys = Object.keys(style);
    return styleKeys
        .map(function (styleProp) {
        const value = style[styleProp];
        return getTransformValueWithUnits(styleProp, value);
    })
        .reduce(function (transform, value) {
        return (transform += ` ${value}`);
    }, '')
        .trim();
}

/**
 * getNonAnimatableStyle function returns the non-animatable style object
 * @param style - CSSProperties
 * @returns - non-animatable CSSProperties
 */
function getNonAnimatableStyle(style, transformObjectRef) {
    const stylesWithoutTransforms = Object.keys(style).reduce((resultObject, styleProp) => {
        const value = style[styleProp];
        // skips all the subscribers here
        // only get non-animatable styles
        if (isTransitionValue(value)) {
            return resultObject;
        }
        else if (styleTrasformKeys.indexOf(styleProp) !== -1) {
            // if not subscriber, then check styleTransformKeys
            // add it to transformPropertiesObjectRef
            transformObjectRef.current[styleProp] = value;
            return resultObject;
        }
        return Object.assign(Object.assign({}, resultObject), { [styleProp]: value });
    }, {});
    const transformStyle = {};
    if (Object.keys(transformObjectRef.current).length > 0) {
        transformStyle.transform = getTransform(transformObjectRef.current);
    }
    // combined transform and non-transform styles
    const combinedStyle = Object.assign(Object.assign({}, transformStyle), stylesWithoutTransforms);
    return combinedStyle;
}

/**
 * Function to get clean props object without any subscribers
 */
const getCleanProps = (props) => {
    const cleanProps = Object.assign({}, props);
    if (cleanProps.style) {
        delete cleanProps.style;
    }
    Object.keys(cleanProps).forEach((prop) => {
        if (isTransitionValue(cleanProps[prop])) {
            delete cleanProps[prop];
        }
    });
    return cleanProps;
};

const tags = [
    'a',
    'abbr',
    'acronym',
    'address',
    'applet',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'basefont',
    'bdi',
    'bdo',
    'bgsound',
    'big',
    'blink',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'center',
    'circle',
    'cite',
    'clipPath',
    'code',
    'col',
    'colgroup',
    'command',
    'content',
    'data',
    'datalist',
    'dd',
    'defs',
    'del',
    'details',
    'dfn',
    'dialog',
    'dir',
    'div',
    'dl',
    'dt',
    'element',
    'ellipse',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'font',
    'footer',
    'foreignObject',
    'form',
    'frame',
    'frameset',
    'g',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'image',
    'img',
    'input',
    'ins',
    'isindex',
    'kbd',
    'keygen',
    'label',
    'legend',
    'li',
    'line',
    'linearGradient',
    'link',
    'listing',
    'main',
    'map',
    'mark',
    'marquee',
    'mask',
    'math',
    'menu',
    'menuitem',
    'meta',
    'meter',
    'multicol',
    'nav',
    'nextid',
    'nobr',
    'noembed',
    'noframes',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'param',
    'path',
    'pattern',
    'picture',
    'plaintext',
    'polygon',
    'polyline',
    'pre',
    'progress',
    'q',
    'radialGradient',
    'rb',
    'rbc',
    'rect',
    'rp',
    'rt',
    'rtc',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'shadow',
    'slot',
    'small',
    'source',
    'spacer',
    'span',
    'stop',
    'strike',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'svg',
    'table',
    'tbody',
    'td',
    'template',
    'text',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'track',
    'tspan',
    'tt',
    'u',
    'ul',
    'var',
    'video',
    'wbr',
    'xmp',
];
const unitlessStyleProps = [
    'borderImageOutset',
    'borderImageSlice',
    'borderImageWidth',
    'fontWeight',
    'lineHeight',
    'opacity',
    'orphans',
    'tabSize',
    'widows',
    'zIndex',
    'zoom',
    // SVG-related properties
    'fillOpacity',
    'floodOpacity',
    'stopOpacity',
    'strokeDasharray',
    'strokeDashoffset',
    'strokeMiterlimit',
    'strokeOpacity',
    'strokeWidth',
    // prefixed
    'animationIterationCount',
    'boxFlex',
    'boxFlexGroup',
    'boxOrdinalGroup',
    'columnCount',
    'flex',
    'flexGrow',
    'flexPositive',
    'flexShrink',
    'flexNegative',
    'flexOrder',
    'gridRow',
    'gridColumn',
    'order',
    'lineClamp',
];

/**
 * getCssValue() function to get css value with unit or without unit
 * it is only for style property - it cannot be used with transform keys
 * @param property - style property
 * @param value - style value
 * @returns - value with unit or without unit
 */
function getCssValue(property, value) {
    let cssValue;
    if (typeof value === "number") {
        if (unitlessStyleProps.indexOf(property) !== -1) {
            cssValue = value;
        }
        else {
            cssValue = value + "px";
        }
    }
    else {
        cssValue = value;
    }
    return cssValue;
}

/**
 * isDefined to check the value is defined or not
 * @param value - any
 * @returns - boolean
 */
const isDefined = (value) => {
    return value !== null && value !== undefined;
};

/**
 * Function to convert camel case to dashed case
 * eg: backgroundColor -> background-color
 *
 * @param str
 */
function camelToDash(str) {
    if (str != str.toLowerCase()) {
        str = str.replace(/[A-Z]/g, (m) => '-' + m.toLowerCase());
    }
    return str;
}

const _internalInterpolate = (val, arr, extrapolateLeft, extrapolateRight) => {
    const [inputMin, inputMax, outputMin, outputMax] = arr;
    let result = val;
    // EXTRAPOLATE
    if (result < inputMin) {
        if (extrapolateLeft === 'identity') {
            return result;
        }
        else if (extrapolateLeft === 'clamp') {
            result = inputMin;
        }
        else ;
    }
    if (result > inputMax) {
        if (extrapolateRight === 'identity') {
            return result;
        }
        else if (extrapolateRight === 'clamp') {
            result = inputMax;
        }
        else ;
    }
    if (outputMin === outputMax) {
        return outputMin;
    }
    if (inputMin === inputMax) {
        if (val <= inputMin) {
            return outputMin;
        }
        return outputMax;
    }
    // Input Range
    if (inputMin === -Infinity) {
        result = -result;
    }
    else if (inputMax === Infinity) {
        result = result - inputMin;
    }
    else {
        result = (result - inputMin) / (inputMax - inputMin);
    }
    // Output Range
    if (outputMin === -Infinity) {
        result = -result;
    }
    else if (outputMax === Infinity) {
        result = result + outputMin;
    }
    else {
        result = result * (outputMax - outputMin) + outputMin;
    }
    return result;
};
const _getNarrowedInputArray = function (x, input, output) {
    const length = input.length;
    let narrowedInput = [];
    // Boundaries
    if (x < input[0]) {
        narrowedInput = [input[0], input[1], output[0], output[1]];
    }
    else if (x > input[length - 1]) {
        narrowedInput = [
            input[length - 2],
            input[length - 1],
            output[length - 2],
            output[length - 1],
        ];
    }
    // Narrow the input and output ranges
    for (let i = 1; i < length; ++i) {
        if (x <= input[i]) {
            narrowedInput = [input[i - 1], input[i], output[i - 1], output[i]];
            break;
        }
    }
    return narrowedInput;
};
const _getColorInterpolate = (value, narrowedInput) => {
    const [inputMin, inputMax, outputMin, outputMax] = narrowedInput;
    const outputMinProcessed = hexToRgba(outputMin);
    const outputMaxProcessed = hexToRgba(outputMax);
    const red = _internalInterpolate(value, [inputMin, inputMax, outputMinProcessed.r, outputMaxProcessed.r], 'clamp', 'clamp');
    const green = _internalInterpolate(value, [inputMin, inputMax, outputMinProcessed.g, outputMaxProcessed.g], 'clamp', 'clamp');
    const blue = _internalInterpolate(value, [inputMin, inputMax, outputMinProcessed.b, outputMaxProcessed.b], 'clamp', 'clamp');
    const alpha = _internalInterpolate(value, [inputMin, inputMax, outputMinProcessed.a, outputMaxProcessed.a], 'clamp', 'clamp');
    return rgbaToHex({ r: red, g: green, b: blue, a: alpha });
};
const _getArrayInterpolate = (value, narrowedInput, _extrapolateLeft, _extrapolateRight) => {
    const [inputMin, inputMax, outputMin, outputMax] = narrowedInput;
    if (outputMin.length === outputMax.length) {
        return outputMin.map((val, index) => {
            if (typeof val === 'string') {
                // IF IT IS STRING THEN IT MUST BE HEX COLOR
                return _getColorInterpolate(value, [
                    inputMin,
                    inputMax,
                    val,
                    outputMax[index],
                ]);
            }
            else {
                return _internalInterpolate(value, [inputMin, inputMax, val, outputMax[index]], _extrapolateLeft, _extrapolateRight);
            }
        });
    }
    else {
        throw new Error("Array length doesn't match");
    }
};
const _getTemplateString = (str) => {
    return str.replace(COLOR_NUMBER_REGEX, function (match) {
        if (match.indexOf(' ') === 0) {
            return ' $';
        }
        return '$';
    });
};
const _getParsedStringArray = (str) => {
    return str.match(COLOR_NUMBER_REGEX).map((v) => {
        if (v.indexOf('#') !== -1) {
            return v;
        }
        else {
            return Number(v);
        }
    });
};
/**
 * Function returns if the template of two strings are matched
 * i.e. they can be interpolated
 * @param str1 - first string
 * @param str2 - second string
 * @returns boolean indicating two strings matched or not
 */
const stringMatched = (str1, str2) => {
    return (_getTemplateString(str1).trim().replace(/\s/g, '').length ===
        _getTemplateString(str2).trim().replace(/\s/g, '').length);
};
/**
 * Function which proccess the
 * hexadecimal colors to its proper formats
 * @param str - string
 * @returns hex color string
 */
const getProcessedColor = (str) => {
    return str.replace(HEX_NAME_COLOR, function (match) {
        if (match.indexOf('#') !== -1) {
            return rgbaToHex(hexToRgba(match));
        }
        else if (Object.prototype.hasOwnProperty.call(colorNames, match)) {
            return colorNames[match];
        }
        else {
            throw new Error('String cannot be parsed!');
        }
    });
};
/**
 * interpolateNumbers to interpolate the numeric value
 * @param value - number
 * @param inputRange
 * @param outputRange
 * @param extrapolateConfig
 * @returns - number | string
 */
function interpolateNumbers(value, inputRange, outputRange, extrapolateConfig) {
    const extrapolate = extrapolateConfig === null || extrapolateConfig === void 0 ? void 0 : extrapolateConfig.extrapolate;
    const extrapolateLeft = extrapolateConfig === null || extrapolateConfig === void 0 ? void 0 : extrapolateConfig.extrapolateLeft;
    const extrapolateRight = extrapolateConfig === null || extrapolateConfig === void 0 ? void 0 : extrapolateConfig.extrapolateRight;
    const narrowedInput = _getNarrowedInputArray(value, inputRange, outputRange);
    let _extrapolateLeft = 'extend';
    if (extrapolateLeft !== undefined) {
        _extrapolateLeft = extrapolateLeft;
    }
    else if (extrapolate !== undefined) {
        _extrapolateLeft = extrapolate;
    }
    let _extrapolateRight = 'extend';
    if (extrapolateRight !== undefined) {
        _extrapolateRight = extrapolateRight;
    }
    else if (extrapolate !== undefined) {
        _extrapolateRight = extrapolate;
    }
    if (outputRange.length) {
        if (typeof outputRange[0] === 'number') {
            return _internalInterpolate(value, narrowedInput, _extrapolateLeft, _extrapolateRight);
        }
        else if (Array.isArray(outputRange[0])) {
            return _getArrayInterpolate(value, narrowedInput, _extrapolateLeft, _extrapolateRight);
        }
        else {
            const [inputMin, inputMax, outputMin, outputMax] = narrowedInput;
            const processedOutputMin = getProcessedColor(outputMin);
            const processedOutputMax = getProcessedColor(outputMax);
            let templateString = _getTemplateString(processedOutputMin);
            if (stringMatched(processedOutputMin, processedOutputMax)) {
                const outputMinParsed = _getParsedStringArray(processedOutputMin);
                const outputMaxParsed = _getParsedStringArray(processedOutputMax);
                const result = _getArrayInterpolate(value, [inputMin, inputMax, outputMinParsed, outputMaxParsed], _extrapolateLeft, _extrapolateRight);
                for (const v of result)
                    templateString = templateString.replace('$', v);
                return templateString;
            }
            else {
                throw new Error("Output range doesn't match string format!");
            }
        }
    }
    else {
        throw new Error('Output range cannot be Empty');
    }
}
/**
 * interpolateTransitionValue to interpolating TransitionValue type value
 * @param value
 * @param inputRange
 * @param outputRange
 * @param extrapolateConfig
 * @returns TransitionValue
 */
const interpolateTransitionValue = (value, inputRange, outputRange, extrapolateConfig) => {
    return Object.assign(Object.assign({}, value), { isInterpolation: true, interpolationConfig: {
            inputRange,
            outputRange,
            extrapolateConfig,
        } });
};
/**
 * interpolate function to interpolate both transition
 * as well as numerical value
 * @param value
 * @param inputRange
 * @param outputRange
 * @param extrapolateConfig
 */
const interpolate = (value, inputRange, outputRange, extrapolateConfig) => {
    if (isTransitionValue(value)) {
        return interpolateTransitionValue(value, inputRange, outputRange, extrapolateConfig);
    }
    else if (typeof value === 'number') {
        return interpolateNumbers(value, inputRange, outputRange, extrapolateConfig);
    }
    else {
        throw new Error(`'${typeof value}' cannot be interpolated!`);
    }
};

// Combine multiple refs
function combineRefs(...refs) {
    return function applyRef(element) {
        refs.forEach((ref) => {
            if (!ref) {
                return;
            }
            if (typeof ref === "function") {
                ref(element);
                return;
            }
            if ("current" in ref) {
                // @ts-ignore
                ref.current = element;
            }
        });
    };
}

/**
 * Higher order component to make any component animatable
 * @param WrapperComponent
 */
function makeAnimatedComponent(WrapperComponent) {
    function Wrapper(props, forwardRef) {
        const ref = React__default["default"].useRef(null);
        // for transforms, we add all the transform keys in transformPropertiesObjectRef and
        // use getTransform() function to get transform string.
        // we make sure that the non-animatable transforms to be present in
        // transformPropertiesObjectRef , non-animatable transform from first paint
        // are overridden if it is not added.
        const transformPropertiesObjectRef = React__default["default"].useRef({});
        // generates the array of animation object
        const animations = React__default["default"].useMemo(() => {
            var _a;
            const animatableStyles = getAnimatableObject('style', (_a = props.style) !== null && _a !== void 0 ? _a : Object.create({}));
            const animatableProps = getAnimatableObject('props', props !== null && props !== void 0 ? props : Object.create({}));
            return [...animatableStyles, ...animatableProps];
        }, [props]);
        /**
         * Update non-animated style if style changes...
         * here useLayoutEffect is used so that the changes is reflected
         * as soon as possible
         */
        React__default["default"].useLayoutEffect(() => {
            if (!props.style) {
                return;
            }
            const nonAnimatableStyle = getNonAnimatableStyle(props.style, transformPropertiesObjectRef);
            Object.keys(nonAnimatableStyle).forEach((styleProp) => {
                const value = nonAnimatableStyle[styleProp];
                if (ref.current) {
                    ref.current.style[styleProp] = getCssValue(styleProp, value);
                }
            });
        }, [props.style]);
        React__default["default"].useLayoutEffect(() => {
            animations.forEach((props) => {
                const { _subscribe, _value, _config, _currentValue, propertyType, property, animatable, } = props;
                // store animations here
                let animation = null;
                if (!ref.current) {
                    return;
                }
                // whether or not the property is one of transform keys
                const isTransform = styleTrasformKeys.indexOf(property) !== -1;
                // called every frame to update new transform values
                // getTransform function returns the valid transform string
                const getTransformValue = (value) => {
                    transformPropertiesObjectRef.current[property] = value;
                    return getTransform(transformPropertiesObjectRef.current);
                };
                // to apply animation values to a ref node
                const applyAnimationValues = (value) => {
                    if (ref.current) {
                        if (propertyType === 'style') {
                            // set animation to style
                            if (isTransform) {
                                ref.current.style.transform = getTransformValue(value);
                            }
                            else {
                                ref.current.style[property] = getCssValue(property, value);
                            }
                        }
                        else if (propertyType === 'props') {
                            // set animation to property
                            ref.current.setAttribute(camelToDash(property), value);
                        }
                    }
                };
                const onFrame = (value) => {
                    _currentValue.current = value;
                    // for interpolation we check isInterpolation boolean
                    // which is injected from interpolate function
                    if (props.isInterpolation) {
                        const { interpolationConfig } = props;
                        const interpolatedValue = interpolateNumbers(value, interpolationConfig.inputRange, interpolationConfig.outputRange, interpolationConfig.extrapolateConfig);
                        // interpolate it first and
                        // apply animation to ref node
                        applyAnimationValues(interpolatedValue);
                    }
                    else {
                        // if it is FluidValue, we dont have to interpolate it
                        // just apply animation value
                        applyAnimationValues(value);
                    }
                };
                /**
                 * Function to initialize dynamic animations according to config
                 * "spring" or "timing" based animations are
                 * determined by the config duration
                 */
                const defineAnimation = (value, config) => {
                    const animationConfig = Object.assign(Object.assign({}, _config), config);
                    let type;
                    /**
                     * Here duration key determines the type of animation
                     * spring config are overridden by duration
                     */
                    if (isDefined(animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.duration) ||
                        (animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.immediate)) {
                        type = 'timing';
                    }
                    else {
                        type = 'spring';
                    }
                    if (type === 'spring') {
                        animation = new SpringAnimation({
                            initialPosition: value,
                            config: animationConfig,
                        });
                    }
                    else if (type === 'timing') {
                        animation = new TimingAnimation({
                            initialPosition: value,
                            config: animationConfig,
                        });
                    }
                };
                const onUpdate = (value, callback) => {
                    const { toValue, config } = value;
                    if (animatable) {
                        const previousAnimation = animation;
                        // animatable
                        if (previousAnimation._toValue !== toValue) {
                            /**
                             * stopping animation here would affect in whole
                             * animation pattern, requestAnimationFrame instance
                             * is created on frequent calls like mousemove
                             * it flushes current running requestAnimationFrame
                             */
                            animation.stop();
                            // re-define animation here with different configuration
                            // used for dynamic animation
                            defineAnimation(previousAnimation._position, config);
                            // invoke onStart function
                            (config === null || config === void 0 ? void 0 : config.onStart) && config.onStart(previousAnimation._position);
                            // start animations here by start api
                            animation.start({
                                toValue,
                                onFrame,
                                previousAnimation,
                                onEnd: callback,
                            });
                        }
                    }
                    else {
                        // non-animatable
                        if (typeof toValue === typeof _value) {
                            if (ref.current) {
                                ref.current.style[property] = getCssValue(property, toValue);
                            }
                        }
                        else {
                            throw new Error('Cannot set different types of animation values');
                        }
                    }
                };
                // called initially to paint the frame with initial value '_value'
                onFrame(_value);
                if (animatable) {
                    // define type of animation to paint the first frame with initial value '_value'
                    defineAnimation(_value);
                }
                _subscribe(onUpdate, property, Date.now());
            });
            return () => {
            };
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);
        return React__default["default"].createElement(WrapperComponent, Object.assign(Object.assign({}, getCleanProps(props)), { ref: combineRefs(ref, forwardRef) }));
    }
    return React__default["default"].forwardRef(Wrapper);
}
const animated = {};
tags.forEach((element) => {
    animated[element] = makeAnimatedComponent(element);
});

class TransitionValue {
    constructor(initialValue, config) {
        this._subscriptions = new Map();
        this._subscribe = (onUpdate, property, uuid) => {
            this._subscriptions.set({ uuid, property }, onUpdate);
            return () => {
                this._subscriptions.delete({ uuid, property });
            };
        };
        this._value = initialValue;
        this._currentValue = { current: initialValue };
        this._config = config;
        this.get = () => this._currentValue.current;
    }
    /**
     * Animates from initial value to updated value, determines the transition type `multistage`
     * or `singlestage` according to updatedValue
     */
    setValue(updatedValue, callback) {
        /** Multistage transition */
        if (typeof updatedValue === 'function') {
            updatedValue((nextValue) => {
                const multiStagePromise = new Promise((resolve) => {
                    for (const subscriptionKey of this._subscriptions.keys()) {
                        const updater = this._subscriptions.get(subscriptionKey);
                        if (updater) {
                            updater(nextValue, function (result) {
                                if (result.finished) {
                                    resolve(nextValue);
                                }
                                if (callback) {
                                    callback(result);
                                }
                            });
                        }
                    }
                });
                return multiStagePromise;
            });
            return;
        }
        /** Singlestage transition */
        for (const subscriptionKey of this._subscriptions.keys()) {
            const updater = this._subscriptions.get(subscriptionKey);
            updater && updater(updatedValue, callback);
        }
    }
}

/**
 * Transition hook
 *
 * @param initialValue - initial value
 * @param config - the config object for `TransitionValue`
 */
function useTransition(initialValue, config) {
    const isInitial = React__default["default"].useRef(true);
    const transition = React__default["default"].useRef(new TransitionValue(initialValue, config)).current;
    /**
     * trigger animation on argument change
     * doesn't fire the setValue method on initial render
     */
    React__default["default"].useEffect(() => {
        if (!isInitial.current) {
            transition.setValue({ toValue: initialValue, config });
        }
        isInitial.current = false;
    }, [initialValue]);
    return [transition, transition.setValue.bind(transition)];
}

/**
 * Mount hook
 * applies mounting and unmounting of a component according to state change
 * applying transitions
 *
 * @param state - boolean indicating mount state of a component
 * @param config - the config object `UseMountConfig`
 */
function useMount(state, config) {
    const initial = React__default["default"].useRef(true);
    const [mounted, setMounted] = React__default["default"].useState(state);
    const { from, enter, exit, config: innerConfig, enterConfig, exitConfig, } = React__default["default"].useRef(config).current;
    const [animation, setAnimation] = useTransition(from, innerConfig);
    React__default["default"].useEffect(() => {
        if (state) {
            initial.current = true;
            setMounted(true);
        }
        else {
            initial.current = false;
            setAnimation(typeof exit === 'number'
                ? {
                    toValue: exit,
                    config: exitConfig,
                }
                : exit, function ({ finished }) {
                if (finished) {
                    setMounted(false);
                }
            });
        }
    }, [state]);
    React__default["default"].useEffect(() => {
        if (mounted && initial.current) {
            setAnimation(typeof enter === 'number'
                ? {
                    toValue: enter,
                    config: enterConfig,
                }
                : enter);
        }
    }, [mounted, initial.current]);
    return function (callback) {
        return callback(animation, mounted);
    };
}

exports.Easing = Easing;
exports.TransitionValue = TransitionValue;
exports.animated = animated;
exports.interpolate = interpolate;
exports.interpolateNumbers = interpolateNumbers;
exports.interpolateTransitionValue = interpolateTransitionValue;
exports.isTransitionValue = isTransitionValue;
exports.makeAnimatedComponent = makeAnimatedComponent;
exports.useMount = useMount;
exports.useTransition = useTransition;
//# sourceMappingURL=index.js.map
