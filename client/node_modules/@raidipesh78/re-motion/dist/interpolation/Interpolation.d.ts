import { FluidValue } from '../types';
declare type ExtrapolateType = 'identity' | 'extend' | 'clamp';
export interface ExtrapolateConfig {
    extrapolate?: ExtrapolateType;
    extrapolateRight?: ExtrapolateType;
    extrapolateLeft?: ExtrapolateType;
}
/**
 * interpolateNumbers to interpolate the numeric value
 * @param value - number
 * @param inputRange
 * @param outputRange
 * @param extrapolateConfig
 * @returns - number | string
 */
export declare function interpolateNumbers(value: number, inputRange: Array<number>, outputRange: Array<number | string>, extrapolateConfig?: ExtrapolateConfig): any;
/**
 * interpolateTransitionValue to interpolating TransitionValue type value
 * @param value
 * @param inputRange
 * @param outputRange
 * @param extrapolateConfig
 * @returns TransitionValue
 */
export declare const interpolateTransitionValue: (value: FluidValue, inputRange: Array<number>, outputRange: Array<number | string>, extrapolateConfig?: ExtrapolateConfig) => {
    isInterpolation: boolean;
    interpolationConfig: {
        inputRange: number[];
        outputRange: (string | number)[];
        extrapolateConfig: ExtrapolateConfig | undefined;
    };
    _subscribe: import("../types").SubscribeFn;
    _value: import("../types").Length;
    _currentValue: {
        current: import("../types").Length;
    };
    _config?: import("../types").TransitionValueConfig | undefined;
    get: () => import("../types").Length;
};
/**
 * interpolate function to interpolate both transition
 * as well as numerical value
 * @param value
 * @param inputRange
 * @param outputRange
 * @param extrapolateConfig
 */
export declare const interpolate: (value: number | FluidValue, inputRange: Array<number>, outputRange: Array<number | string>, extrapolateConfig?: ExtrapolateConfig) => any;
export {};
