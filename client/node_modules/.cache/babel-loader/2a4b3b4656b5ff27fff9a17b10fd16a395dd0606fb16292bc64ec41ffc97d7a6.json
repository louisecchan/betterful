{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/chanchinghei/Library/Mobile Documents/com~apple~CloudDocs/Documents/Work/Fully Remote \\uD83C\\uDF0E/Options/Coding/Projects/shop/client/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/chanchinghei/Library/Mobile Documents/com~apple~CloudDocs/Documents/Work/Fully Remote \\uD83C\\uDF0E/Options/Coding/Projects/shop/client/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createWebhooks = void 0;\nvar Error_js_1 = require(\"./Error.js\");\nfunction createWebhooks(platformFunctions) {\n  var Webhook = {\n    DEFAULT_TOLERANCE: 300,\n    // @ts-ignore\n    signature: null,\n    constructEvent: function constructEvent(payload, header, secret, tolerance, cryptoProvider) {\n      this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n      var jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder('utf8').decode(payload)) : JSON.parse(payload);\n      return jsonPayload;\n    },\n    constructEventAsync: function constructEventAsync(payload, header, secret, tolerance, cryptoProvider) {\n      var _this = this;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var jsonPayload;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n            case 2:\n              jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder('utf8').decode(payload)) : JSON.parse(payload);\n              return _context.abrupt(\"return\", jsonPayload);\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }))();\n    },\n    /**\n     * Generates a header to be used for webhook mocking\n     *\n     * @typedef {object} opts\n     * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n     * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n     * @property {string} secret - Stripe webhook secret 'whsec_...'\n     * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n     * @property {string} signature - Computed webhook signature\n     * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.\n     */\n    generateTestHeaderString: function generateTestHeaderString(opts) {\n      if (!opts) {\n        throw new Error_js_1.StripeError({\n          message: 'Options are required'\n        });\n      }\n      opts.timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n      opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;\n      opts.cryptoProvider = opts.cryptoProvider || getCryptoProvider();\n      opts.signature = opts.signature || opts.cryptoProvider.computeHMACSignature(opts.timestamp + '.' + opts.payload, opts.secret);\n      var generatedHeader = ['t=' + opts.timestamp, opts.scheme + '=' + opts.signature].join(',');\n      return generatedHeader;\n    }\n  };\n  var signature = {\n    EXPECTED_SCHEME: 'v1',\n    verifyHeader: function verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n      var _parseEventDetails = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME),\n        header = _parseEventDetails.decodedHeader,\n        payload = _parseEventDetails.decodedPayload,\n        details = _parseEventDetails.details,\n        suspectPayloadType = _parseEventDetails.suspectPayloadType;\n      cryptoProvider = cryptoProvider || getCryptoProvider();\n      var expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);\n      validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType);\n      return true;\n    },\n    verifyHeaderAsync: function verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n      var _this2 = this;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _parseEventDetails2, header, payload, details, suspectPayloadType, expectedSignature;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _parseEventDetails2 = parseEventDetails(encodedPayload, encodedHeader, _this2.EXPECTED_SCHEME), header = _parseEventDetails2.decodedHeader, payload = _parseEventDetails2.decodedPayload, details = _parseEventDetails2.details, suspectPayloadType = _parseEventDetails2.suspectPayloadType;\n              cryptoProvider = cryptoProvider || getCryptoProvider();\n              _context2.next = 4;\n              return cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);\n            case 4:\n              expectedSignature = _context2.sent;\n              return _context2.abrupt(\"return\", validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType));\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }))();\n    }\n  };\n  function makeHMACContent(payload, details) {\n    return \"\".concat(details.timestamp, \".\").concat(payload);\n  }\n  function parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {\n    if (!encodedPayload) {\n      throw new Error_js_1.StripeSignatureVerificationError(encodedHeader, encodedPayload, {\n        message: 'No webhook payload was provided.'\n      });\n    }\n    var suspectPayloadType = typeof encodedPayload != 'string' && !(encodedPayload instanceof Uint8Array);\n    var textDecoder = new TextDecoder('utf8');\n    var decodedPayload = encodedPayload instanceof Uint8Array ? textDecoder.decode(encodedPayload) : encodedPayload;\n    // Express's type for `Request#headers` is `string | []string`\n    // which is because the `set-cookie` header is an array,\n    // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)\n    // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)\n    if (Array.isArray(encodedHeader)) {\n      throw new Error('Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.');\n    }\n    if (encodedHeader == null || encodedHeader == '') {\n      throw new Error_js_1.StripeSignatureVerificationError(encodedHeader, encodedPayload, {\n        message: 'No stripe-signature header value was provided.'\n      });\n    }\n    var decodedHeader = encodedHeader instanceof Uint8Array ? textDecoder.decode(encodedHeader) : encodedHeader;\n    var details = parseHeader(decodedHeader, expectedScheme);\n    if (!details || details.timestamp === -1) {\n      throw new Error_js_1.StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n        message: 'Unable to extract timestamp and signatures from header'\n      });\n    }\n    if (!details.signatures.length) {\n      throw new Error_js_1.StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n        message: 'No signatures found with expected scheme'\n      });\n    }\n    return {\n      decodedPayload: decodedPayload,\n      decodedHeader: decodedHeader,\n      details: details,\n      suspectPayloadType: suspectPayloadType\n    };\n  }\n  function validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType) {\n    var signatureFound = !!details.signatures.filter(platformFunctions.secureCompare.bind(platformFunctions, expectedSignature)).length;\n    if (!signatureFound) {\n      if (suspectPayloadType) {\n        throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n          message: 'Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body.' + 'Payload was provided as a parsed JavaScript object instead. \\n' + 'Signature verification is impossible without access to the original signed material. \\n' + 'Learn more about webhook signing and explore webhook integration examples for various frameworks at ' + 'https://github.com/stripe/stripe-node#webhook-signing'\n        });\n      }\n      throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n        message: 'No signatures found matching the expected signature for payload.' + ' Are you passing the raw request body you received from Stripe? \\n' + 'Learn more about webhook signing and explore webhook integration examples for various frameworks at ' + 'https://github.com/stripe/stripe-node#webhook-signing'\n      });\n    }\n    var timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n    if (tolerance > 0 && timestampAge > tolerance) {\n      // @ts-ignore\n      throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n        message: 'Timestamp outside the tolerance zone'\n      });\n    }\n    return true;\n  }\n  function parseHeader(header, scheme) {\n    if (typeof header !== 'string') {\n      return null;\n    }\n    return header.split(',').reduce(function (accum, item) {\n      var kv = item.split('=');\n      if (kv[0] === 't') {\n        accum.timestamp = parseInt(kv[1], 10);\n      }\n      if (kv[0] === scheme) {\n        accum.signatures.push(kv[1]);\n      }\n      return accum;\n    }, {\n      timestamp: -1,\n      signatures: []\n    });\n  }\n  var webhooksCryptoProviderInstance = null;\n  /**\n   * Lazily instantiate a CryptoProvider instance. This is a stateless object\n   * so a singleton can be used here.\n   */\n  function getCryptoProvider() {\n    if (!webhooksCryptoProviderInstance) {\n      webhooksCryptoProviderInstance = platformFunctions.createDefaultCryptoProvider();\n    }\n    return webhooksCryptoProviderInstance;\n  }\n  Webhook.signature = signature;\n  return Webhook;\n}\nexports.createWebhooks = createWebhooks;","map":{"version":3,"names":["_regeneratorRuntime","require","default","_asyncToGenerator","Object","defineProperty","exports","value","createWebhooks","Error_js_1","platformFunctions","Webhook","DEFAULT_TOLERANCE","signature","constructEvent","payload","header","secret","tolerance","cryptoProvider","verifyHeader","jsonPayload","Uint8Array","JSON","parse","TextDecoder","decode","constructEventAsync","_this","mark","_callee","wrap","_callee$","_context","prev","next","verifyHeaderAsync","abrupt","stop","generateTestHeaderString","opts","StripeError","message","timestamp","Math","floor","Date","now","scheme","EXPECTED_SCHEME","getCryptoProvider","computeHMACSignature","generatedHeader","join","encodedPayload","encodedHeader","_parseEventDetails","parseEventDetails","decodedHeader","decodedPayload","details","suspectPayloadType","expectedSignature","makeHMACContent","validateComputedSignature","_this2","_callee2","_parseEventDetails2","_callee2$","_context2","computeHMACSignatureAsync","sent","concat","expectedScheme","StripeSignatureVerificationError","textDecoder","Array","isArray","Error","parseHeader","signatures","length","signatureFound","filter","secureCompare","bind","timestampAge","split","reduce","accum","item","kv","parseInt","push","webhooksCryptoProviderInstance","createDefaultCryptoProvider"],"sources":["/Users/chanchinghei/Library/Mobile Documents/com~apple~CloudDocs/Documents/Work/Fully Remote ðŸŒŽ/Options/Coding/Projects/shop/client/node_modules/stripe/cjs/Webhooks.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createWebhooks = void 0;\nconst Error_js_1 = require(\"./Error.js\");\nfunction createWebhooks(platformFunctions) {\n    const Webhook = {\n        DEFAULT_TOLERANCE: 300,\n        // @ts-ignore\n        signature: null,\n        constructEvent(payload, header, secret, tolerance, cryptoProvider) {\n            this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n            const jsonPayload = payload instanceof Uint8Array\n                ? JSON.parse(new TextDecoder('utf8').decode(payload))\n                : JSON.parse(payload);\n            return jsonPayload;\n        },\n        async constructEventAsync(payload, header, secret, tolerance, cryptoProvider) {\n            await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n            const jsonPayload = payload instanceof Uint8Array\n                ? JSON.parse(new TextDecoder('utf8').decode(payload))\n                : JSON.parse(payload);\n            return jsonPayload;\n        },\n        /**\n         * Generates a header to be used for webhook mocking\n         *\n         * @typedef {object} opts\n         * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n         * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n         * @property {string} secret - Stripe webhook secret 'whsec_...'\n         * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n         * @property {string} signature - Computed webhook signature\n         * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.\n         */\n        generateTestHeaderString: function (opts) {\n            if (!opts) {\n                throw new Error_js_1.StripeError({\n                    message: 'Options are required',\n                });\n            }\n            opts.timestamp =\n                Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n            opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;\n            opts.cryptoProvider = opts.cryptoProvider || getCryptoProvider();\n            opts.signature =\n                opts.signature ||\n                    opts.cryptoProvider.computeHMACSignature(opts.timestamp + '.' + opts.payload, opts.secret);\n            const generatedHeader = [\n                't=' + opts.timestamp,\n                opts.scheme + '=' + opts.signature,\n            ].join(',');\n            return generatedHeader;\n        },\n    };\n    const signature = {\n        EXPECTED_SCHEME: 'v1',\n        verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n            const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType, } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n            cryptoProvider = cryptoProvider || getCryptoProvider();\n            const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);\n            validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType);\n            return true;\n        },\n        async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n            const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType, } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n            cryptoProvider = cryptoProvider || getCryptoProvider();\n            const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);\n            return validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType);\n        },\n    };\n    function makeHMACContent(payload, details) {\n        return `${details.timestamp}.${payload}`;\n    }\n    function parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {\n        if (!encodedPayload) {\n            throw new Error_js_1.StripeSignatureVerificationError(encodedHeader, encodedPayload, {\n                message: 'No webhook payload was provided.',\n            });\n        }\n        const suspectPayloadType = typeof encodedPayload != 'string' &&\n            !(encodedPayload instanceof Uint8Array);\n        const textDecoder = new TextDecoder('utf8');\n        const decodedPayload = encodedPayload instanceof Uint8Array\n            ? textDecoder.decode(encodedPayload)\n            : encodedPayload;\n        // Express's type for `Request#headers` is `string | []string`\n        // which is because the `set-cookie` header is an array,\n        // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)\n        // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)\n        if (Array.isArray(encodedHeader)) {\n            throw new Error('Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.');\n        }\n        if (encodedHeader == null || encodedHeader == '') {\n            throw new Error_js_1.StripeSignatureVerificationError(encodedHeader, encodedPayload, {\n                message: 'No stripe-signature header value was provided.',\n            });\n        }\n        const decodedHeader = encodedHeader instanceof Uint8Array\n            ? textDecoder.decode(encodedHeader)\n            : encodedHeader;\n        const details = parseHeader(decodedHeader, expectedScheme);\n        if (!details || details.timestamp === -1) {\n            throw new Error_js_1.StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n                message: 'Unable to extract timestamp and signatures from header',\n            });\n        }\n        if (!details.signatures.length) {\n            throw new Error_js_1.StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n                message: 'No signatures found with expected scheme',\n            });\n        }\n        return {\n            decodedPayload,\n            decodedHeader,\n            details,\n            suspectPayloadType,\n        };\n    }\n    function validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType) {\n        const signatureFound = !!details.signatures.filter(platformFunctions.secureCompare.bind(platformFunctions, expectedSignature)).length;\n        if (!signatureFound) {\n            if (suspectPayloadType) {\n                throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n                    message: 'Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body.' +\n                        'Payload was provided as a parsed JavaScript object instead. \\n' +\n                        'Signature verification is impossible without access to the original signed material. \\n' +\n                        'Learn more about webhook signing and explore webhook integration examples for various frameworks at ' +\n                        'https://github.com/stripe/stripe-node#webhook-signing',\n                });\n            }\n            throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n                message: 'No signatures found matching the expected signature for payload.' +\n                    ' Are you passing the raw request body you received from Stripe? \\n' +\n                    'Learn more about webhook signing and explore webhook integration examples for various frameworks at ' +\n                    'https://github.com/stripe/stripe-node#webhook-signing',\n            });\n        }\n        const timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n        if (tolerance > 0 && timestampAge > tolerance) {\n            // @ts-ignore\n            throw new Error_js_1.StripeSignatureVerificationError(header, payload, {\n                message: 'Timestamp outside the tolerance zone',\n            });\n        }\n        return true;\n    }\n    function parseHeader(header, scheme) {\n        if (typeof header !== 'string') {\n            return null;\n        }\n        return header.split(',').reduce((accum, item) => {\n            const kv = item.split('=');\n            if (kv[0] === 't') {\n                accum.timestamp = parseInt(kv[1], 10);\n            }\n            if (kv[0] === scheme) {\n                accum.signatures.push(kv[1]);\n            }\n            return accum;\n        }, {\n            timestamp: -1,\n            signatures: [],\n        });\n    }\n    let webhooksCryptoProviderInstance = null;\n    /**\n     * Lazily instantiate a CryptoProvider instance. This is a stateless object\n     * so a singleton can be used here.\n     */\n    function getCryptoProvider() {\n        if (!webhooksCryptoProviderInstance) {\n            webhooksCryptoProviderInstance = platformFunctions.createDefaultCryptoProvider();\n        }\n        return webhooksCryptoProviderInstance;\n    }\n    Webhook.signature = signature;\n    return Webhook;\n}\nexports.createWebhooks = createWebhooks;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}